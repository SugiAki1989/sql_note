## :memo: Overview

実務でよくある`n`件前の売上と比較してどうなのか？というケースで`n`は当然固定されているわけではなく、とりあえず 7 日とか 14 日とか言われるので、機械的にうまく時系列をずらして紐付ける必要がある。このようなケースは`lag`などで指定するわけにもいかないが、不等号を使った`inequality join`で解決できる。

## :floppy_disk: Database

PostgreSQL

## :bookmark: Tag

`inequality join`, `lag`

## :pencil2: Example

```sql
with log1 as (
select createdat, round((random() * (1 - 100))::numeric, 0) + 100 as value
from generate_series('2022-08-01 00:00:00'::timestamp with time zone,
                     '2022-08-10 00:00:00'::timestamp with time zone,
                     '1 day') as createdat
) select * from log1;

       createdat        | value
------------------------+-------
 2022-08-01 00:00:00+09 |    68
 2022-08-02 00:00:00+09 |    20 -- 2022-08-01を紐付けたい
 2022-08-03 00:00:00+09 |    17 -- 2022-08-01、2022-08-02を紐付けたい
 2022-08-04 00:00:00+09 |    83 -- 2022-08-01、2022-08-02、2022-08-03を紐付けたい
 2022-08-05 00:00:00+09 |    34 -- 2022-08-02、2022-08-03、2022-08-04を紐付けたい
 2022-08-06 00:00:00+09 |     9 -- 2022-08-03、2022-08-04、2022-08-05を紐付けたい
 2022-08-07 00:00:00+09 |    76 -- 2022-08-04、2022-08-05、2022-08-06を紐付けたい
 2022-08-08 00:00:00+09 |     3 -- ...という感じ
 2022-08-09 00:00:00+09 |    16
 2022-08-10 00:00:00+09 |    18

```

とりあえず、クエリを先に記載する。見やすくするために水平線を入れている。

```sql
with log1 as (
select createdat, round((random() * (1 - 100))::numeric, 0) + 100 as value
from generate_series('2022-08-01 00:00:00'::timestamp with time zone,
                     '2022-08-10 00:00:00'::timestamp with time zone,
                     '1 day') as createdat
), log2 as (
select
    createdat,
    lag(createdat, 3) over (order by createdat asc) as createdatlag3,
    value
from
    log1
)
select
    x.createdat,
    x.value,
    y.createdat as createdatlag3,
    y.value as valuelag3
from
    log2 as x
left join
    log2 as y
on
    (x.createdatlag3 is null or
    x.createdatlag3 <= y.createdat) and
    y.createdat < x.createdat
order by
    x.createdat asc
;

       createdat        | value |     createdatlag3      | valuelag3 |
------------------------+-------+------------------------+-----------+-
 2022-08-01 00:00:00+09 |    40 |                        |           |
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 2022-08-02 00:00:00+09 |    91 | 2022-08-01 00:00:00+09 |        40 |
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 2022-08-03 00:00:00+09 |    36 | 2022-08-01 00:00:00+09 |        40 |
 2022-08-03 00:00:00+09 |    36 | 2022-08-02 00:00:00+09 |        91 |
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 2022-08-04 00:00:00+09 |    20 | 2022-08-01 00:00:00+09 |        40 |
 2022-08-04 00:00:00+09 |    20 | 2022-08-02 00:00:00+09 |        91 |
 2022-08-04 00:00:00+09 |    20 | 2022-08-03 00:00:00+09 |        36 |
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 2022-08-05 00:00:00+09 |    18 | 2022-08-02 00:00:00+09 |        91 |
 2022-08-05 00:00:00+09 |    18 | 2022-08-03 00:00:00+09 |        36 |
 2022-08-05 00:00:00+09 |    18 | 2022-08-04 00:00:00+09 |        20 |
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 2022-08-06 00:00:00+09 |    55 | 2022-08-03 00:00:00+09 |        36 |
 2022-08-06 00:00:00+09 |    55 | 2022-08-04 00:00:00+09 |        20 |
 2022-08-06 00:00:00+09 |    55 | 2022-08-05 00:00:00+09 |        18 |
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 2022-08-07 00:00:00+09 |    30 | 2022-08-04 00:00:00+09 |        20 |
 2022-08-07 00:00:00+09 |    30 | 2022-08-05 00:00:00+09 |        18 |
 2022-08-07 00:00:00+09 |    30 | 2022-08-06 00:00:00+09 |        55 |
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 2022-08-08 00:00:00+09 |    74 | 2022-08-05 00:00:00+09 |        18 |
 2022-08-08 00:00:00+09 |    74 | 2022-08-06 00:00:00+09 |        55 |
 2022-08-08 00:00:00+09 |    74 | 2022-08-07 00:00:00+09 |        30 |
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 2022-08-09 00:00:00+09 |    12 | 2022-08-06 00:00:00+09 |        55 |
 2022-08-09 00:00:00+09 |    12 | 2022-08-07 00:00:00+09 |        30 |
 2022-08-09 00:00:00+09 |    12 | 2022-08-08 00:00:00+09 |        74 |
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 2022-08-10 00:00:00+09 |    52 | 2022-08-07 00:00:00+09 |        30 |
 2022-08-10 00:00:00+09 |    52 | 2022-08-08 00:00:00+09 |        74 |
 2022-08-10 00:00:00+09 |    52 | 2022-08-09 00:00:00+09 |        12 |
```

`on`の結合条件を見るだけで嫌になるが、「3 日前の`createdat`以上」「各行の`createdat`未満」という条件になっており、各レコードに対して、「3 日前の`createdat`以上 〜 その行の`createdat`未満」が紐づく。3 日前となると、8/1、8/2、8/3 の場合、`join`で`null`が絡んでくるのでその部分の処理。これがないと 8/1、8/2、8/3 が紐付かない。

参考までに不等号の条件判定のイメージ図解を載せておく。

![不等号join](https://user-images.githubusercontent.com/65038325/182414006-1f8e8481-0a66-4a45-8687-9b902f42b643.png)

あとは自己結合した後に取るべきカラムを誤りやすいので注意する。

他の方法として、`between`を使う方法もある。

```sql
with log1 as (
select createdat, round((random() * (1 - 100))::numeric, 0) + 100 as value
from generate_series('2022-08-01 00:00:00'::timestamp with time zone,
                     '2022-08-10 00:00:00'::timestamp with time zone,
                     '1 day') as createdat
), log2 as (
select
    x.createdat as createdat_x,
    x.value as value_x,
    y.createdat as createdat_y,
    y.value as value_y
from
    log1 as x
left join
    log1 as y
on
    y.createdat between x.createdat - interval '3 days' and x.createdat
), log3 as (
select
    *,
    -- 2022-08-01 の行を残すため
    lag(createdat_y, 1) over (order by createdat_x asc) as lag1
from
    log2
)
select
    *
from
    log3
where
    createdat_x != createdat_y or
    lag1 is null
;
```

`between`を使うと自分と同じ日も紐づくので、それは除外する必要があるのと、先頭レコードを残すための処理を追加する必要がある。

```sql
      createdat_x       | value_x |      createdat_y       | value_y
------------------------+---------+------------------------+---------
 2022-08-01 00:00:00+09 |      64 | 2022-08-01 00:00:00+09 |      64
 2022-08-02 00:00:00+09 |      71 | 2022-08-01 00:00:00+09 |      64
 2022-08-02 00:00:00+09 |      71 | 2022-08-02 00:00:00+09 |      71
 2022-08-03 00:00:00+09 |      38 | 2022-08-01 00:00:00+09 |      64
 2022-08-03 00:00:00+09 |      38 | 2022-08-02 00:00:00+09 |      71
 2022-08-03 00:00:00+09 |      38 | 2022-08-03 00:00:00+09 |      38
 2022-08-04 00:00:00+09 |      39 | 2022-08-01 00:00:00+09 |      64
 2022-08-04 00:00:00+09 |      39 | 2022-08-02 00:00:00+09 |      71
 2022-08-04 00:00:00+09 |      39 | 2022-08-03 00:00:00+09 |      38
 2022-08-04 00:00:00+09 |      39 | 2022-08-04 00:00:00+09 |      39
 2022-08-05 00:00:00+09 |      16 | 2022-08-02 00:00:00+09 |      71
 2022-08-05 00:00:00+09 |      16 | 2022-08-03 00:00:00+09 |      38
 2022-08-05 00:00:00+09 |      16 | 2022-08-04 00:00:00+09 |      39
 2022-08-05 00:00:00+09 |      16 | 2022-08-05 00:00:00+09 |      16
```

## おまけ

ユーザーが特定の期間を持っている場合があり、その期間内の行動を紐づけるというケースも個人的には多いので、下記、参考までにメモしておく。

```sql
create table mst_cust
(cuid varchar(5) not null,
 start_dt date not null,
 end_dt date not null
 );

insert into mst_cust values
('x001', '2024-04-10', '2024-04-13'),
('x002', '2024-04-13', '2024-04-15'),
('x003', '2024-04-15', '2024-04-16')
;

create table tran_cust
(cuid varchar(5) not null,
 act_dt date not null
 );

insert into tran_cust values
('x001', '2024-04-08'),
('x001', '2024-04-09'),
('x001', '2024-04-10'),
('x001', '2024-04-11'),
('x001', '2024-04-12'),
('x001', '2024-04-13'),
('x001', '2024-04-14'),
('x001', '2024-04-15'),
('x002', '2024-04-11'),
('x002', '2024-04-12'),
('x002', '2024-04-16'),
('x002', '2024-04-17')
;
```

この例では`mst_cust`に開始と終了期間を持っており、その期間内の行動を紐づけたい。これは不等号結合で解決できる。`x002`は履歴はあるがすべて期間外で、`x003`は履歴がないので紐づくレコードがない。

```sql
select
  m.cuid,
  start_dt,
  end_dt,
  act_dt
from
  mst_cust as m
left join
  tran_cust as t
on
  m.cuid = t.cuid
  and t.act_dt >= m.start_dt
  and m.end_dt >= t.act_dt
;

 cuid |  start_dt  |   end_dt   |   act_dt
------+------------+------------+------------
 x001 | 2024-04-10 | 2024-04-13 | 2024-04-10
 x001 | 2024-04-10 | 2024-04-13 | 2024-04-11
 x001 | 2024-04-10 | 2024-04-13 | 2024-04-12
 x001 | 2024-04-10 | 2024-04-13 | 2024-04-13
 x002 | 2024-04-13 | 2024-04-15 | (null)
 x003 | 2024-04-15 | 2024-04-16 | (null)
(6 rows)
```

## :closed_book: Reference

None
