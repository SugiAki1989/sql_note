## :memo: Overview

たまにレコードを集計したテーブルを集計前の状態に戻したい場合がある。均等に値を割り戻せばよいのであれば戻すことはできなくないが、不均等に戻す場合は不可能である。

例えば合計が`10`というレコードがあり、集計前は`5`レコードあったとする。`5`レコードに`2`という値で戻せばよいのであれば可能だが、`1,1,1,1,6`、`2,1,3,3,1`から`10`に合計されているのであれば、集計前の組み合わせが特定できないので、どうしようもない。

## :floppy_disk: Database

PostgreSQL

## :bookmark: Tag

`inequality join`, `generate_series`

## :pencil2: Example

サンプルテーブルとして、集計後テーブルを用意する。集計された合計とレコード数が記録されているので、これを使って集計前の状態に戻す。

```sql
create table agg(id int, aggsum int, aggcnt int);
insert into
     agg(id, aggsum, aggcnt)
values
    ('1','10','4'),
    ('2','100', '10'),
    ('3','20', '1')
    ;
```

集計レコード数が記録されているので、この値が集計前レコード数を示すので、この値分、レコードを重複させればよい。そのために、最大数を事前に計算して、`generate_series`でテーブルを作成する。

```sql
with tmp as (
    select max(aggcnt) as maxnum from agg
), tmp2 as (
    select generate_series(1, maxnum) as num from tmp
)
select
    id,
    aggsum,
    aggcnt
from
    agg
left join
    tmp2
on
    agg.aggcnt >= tmp2.num
order by
    id asc
;

 id | aggsum | aggcnt
----+--------+--------
  1 |     10 |      4
  1 |     10 |      4
  1 |     10 |      4
  1 |     10 |      4
  2 |    100 |     10
  2 |    100 |     10
  2 |    100 |     10
  2 |    100 |     10
  2 |    100 |     10
  2 |    100 |     10
  2 |    100 |     10
  2 |    100 |     10
  2 |    100 |     10
  2 |    100 |     10
  3 |     20 |      1
(15 rows)
```

これで主計前のレコード数にもどったので、あとは合計を割り戻せば集計前に戻る。

```sql
with tmp as (
    select max(aggcnt) as maxnum from agg
), tmp2 as (
    select generate_series(1, maxnum) as num from tmp
)
select
    id,
    aggsum,
    aggcnt,
    aggsum /aggcnt as originval
from
    agg
left join
    tmp2
on
    agg.aggcnt >= tmp2.num
order by
    id asc
;

 id | aggsum | aggcnt | originval
----+--------+--------+-----------
  1 |     10 |      4 |         2
  1 |     10 |      4 |         2
  1 |     10 |      4 |         2
  1 |     10 |      4 |         2
  2 |    100 |     10 |        10
  2 |    100 |     10 |        10
  2 |    100 |     10 |        10
  2 |    100 |     10 |        10
  2 |    100 |     10 |        10
  2 |    100 |     10 |        10
  2 |    100 |     10 |        10
  2 |    100 |     10 |        10
  2 |    100 |     10 |        10
  2 |    100 |     10 |        10
  3 |     20 |      1 |        20
(15 rows)
```

もう 1 つ似たような例をみておく。この集計されたデータを年ごとに再集計し直すというもの。

```sql
create table unpacking (pid int, sdt date, edt date, avg_price int);
insert into unpacking (pid, sdt, edt, avg_price)
values
('1','2022-12-25','2022-12-30','5'),
('2','2022-12-28','2023-01-01','10'),
('3','2022-12-25','2023-01-05','1');

select * from unpacking;
 pid |    sdt     |    edt     | avg_price
-----+------------+------------+-----------
   1 | 2022-12-25 | 2022-12-30 |         5
   2 | 2022-12-28 | 2023-01-01 |        10
   3 | 2022-12-25 | 2023-01-05 |         1
(3 rows)
```

これも`generate_series`を使えば解決できる。

```sql
with rundt as (
    select dt::date
    from generate_series('2022-12-01'::date,
					     '2023-02-01'::date,
					     '1 day') as dt
)
select * from rundt;

    dt
------------
 2022-12-01
 2022-12-02
 2022-12-03
 2022-12-04
 2022-12-05
 2022-12-06
 2022-12-07
 (snip)
```

この`generate_series`で作ったテーブルを使って不等号結合で紐付ける。あとは、`dt`から年要素を取り出して、`pid`と共に再集計し直せばよい。

```sql
with rundt as (
    select dt::date
    from generate_series('2022-12-01'::date,
					     '2023-02-01'::date,
					     '1 day') as dt
)
select *
from unpacking as u
left join rundt as r
on r.dt >= u.sdt and r.dt <= u.edt
;

 pid |    sdt     |    edt     | avg_price |     dt
-----+------------+------------+-----------+------------
   1 | 2022-12-25 | 2022-12-30 |         5 | 2022-12-25
   1 | 2022-12-25 | 2022-12-30 |         5 | 2022-12-26
   1 | 2022-12-25 | 2022-12-30 |         5 | 2022-12-27
   1 | 2022-12-25 | 2022-12-30 |         5 | 2022-12-28
   1 | 2022-12-25 | 2022-12-30 |         5 | 2022-12-29
   1 | 2022-12-25 | 2022-12-30 |         5 | 2022-12-30
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   2 | 2022-12-28 | 2023-01-01 |        10 | 2022-12-28
   2 | 2022-12-28 | 2023-01-01 |        10 | 2022-12-29
   2 | 2022-12-28 | 2023-01-01 |        10 | 2022-12-30
   2 | 2022-12-28 | 2023-01-01 |        10 | 2022-12-31
   2 | 2022-12-28 | 2023-01-01 |        10 | 2023-01-01
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   3 | 2022-12-25 | 2023-01-05 |         1 | 2022-12-25
   3 | 2022-12-25 | 2023-01-05 |         1 | 2022-12-26
   3 | 2022-12-25 | 2023-01-05 |         1 | 2022-12-27
   3 | 2022-12-25 | 2023-01-05 |         1 | 2022-12-28
   3 | 2022-12-25 | 2023-01-05 |         1 | 2022-12-29
   3 | 2022-12-25 | 2023-01-05 |         1 | 2022-12-30
   3 | 2022-12-25 | 2023-01-05 |         1 | 2022-12-31
   3 | 2022-12-25 | 2023-01-05 |         1 | 2023-01-01
   3 | 2022-12-25 | 2023-01-05 |         1 | 2023-01-02
   3 | 2022-12-25 | 2023-01-05 |         1 | 2023-01-03
   3 | 2022-12-25 | 2023-01-05 |         1 | 2023-01-04
   3 | 2022-12-25 | 2023-01-05 |         1 | 2023-01-05
(23 rows)
```

## :closed_book: Reference

None
