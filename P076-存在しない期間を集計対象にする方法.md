## :memo: Overview

## :floppy_disk: Database

PostgreSQL

## :bookmark: Tag

`generate_series`, `inequality join`

## :pencil2: Example

各商談(`opid`)ごとにステータス(`status`)や金額(`price`)を持っており、そのステータスを登録した日(`date`)が記録されている。例えば、同じ字分秒で`status`は変わらず、`price`が異なるデータが混じっている場合があったりする。システム上、金額が 0 で生成され、金額が付与される業務上の仕様だったりするので、これは先に処理する。他にも、数分や数秒でステータスが更新されたりもする。

```sql
create table sfa(
    opid varchar(10),
    status varchar(1),
    price integer,
    date timestamp
);
insert into sfa(opid, status, price, date)
values
    ('x001','E','10','2020-04-01 12:54:04'),
    ('x001','C','50','2020-04-01 15:36:34'),
    ('x001','B','100','2020-04-05 09:10:00'),
    ('x002','F','0','2020-04-03 12:56:45'),
    ('x002','F','30','2020-04-03 12:56:45'),
    ('x002','B','100','2020-04-03 12:59:15'),
    ('x002','A','150','2020-04-08 12:00:00'),
    ('x003','F','10','2020-04-05 12:15:38')
;

select * from sfa;
 opid | status | price |        date
------+--------+-------+---------------------
 x001 | E      |    10 | 2020-04-01 12:54:04
 x001 | C      |    50 | 2020-04-01 15:36:34
 x001 | B      |   100 | 2020-04-05 09:10:00
 x002 | F      |     0 | 2020-04-03 12:56:45
 x002 | F      |    30 | 2020-04-03 12:56:45
 x002 | B      |   100 | 2020-04-03 12:59:15
 x002 | A      |   150 | 2020-04-08 12:00:00
 x003 | F      |    10 | 2020-04-05 12:15:38
(8 rows)
```

このようなデータがあった場合に、指定した期間を選択すると、その日付内にある`opid`や`price`を計算できるようにしたい。問題は、`opid`がある期間であれば問題ないが、`opid`が期間に含まれていないと、なくなったように見える。例えば、4/3 に`opid`が記録され、ステータスが 4/24 に更新されたとする。4/1~4/10 と期間を指定すると問題ないが、4/10~4/20 にすると、このレコードは進行中にも関わらずデータが無いので、なくなったように見えてしまう。そのため、期間を 4/10~4/20、4/21~4/30 とすると後者の期間で突然ステータスが更新された`opid`だけ表示されるので具合が悪い。これを解消する方法として、進行中の期間を穴埋めするデータ加工を考えたので、そのまとめ。

期間を対応させるテーブルを作成しておく。

```sql
create table time_table(time_stamp timestamp with time zone);
insert into time_table(time_stamp)
select time_stamp
from generate_series('2020-01-01 00:00:00'::timestamp with time zone,
					 '2020-12-31 23:00:00'::timestamp with time zone,
					 '1 hour') as time_stamp
;

          min           |          max           | count
------------------------+------------------------+-------
 2020-01-01 00:00:00+09 | 2020-12-31 23:00:00+09 |  8784
(1 row)
```

まずは、各レコードに対して、次のステータスの 1 秒前の日時を取得する。「同じステータスでも金額が 0 から増える」というシステムのルールに教えてもらえたので、0 はそもそも不要とのこと

```sql
select
    opid,
    status,
    price,
    date,
    lead(date) over(partition by opid order by date asc) - interval '1 second' as leaddate
from
    sfa
where
    price > 0
;

 opid | status | price |        date         |      leaddate
------+--------+-------+---------------------+---------------------
 x001 | E      |    10 | 2020-04-01 12:54:04 | 2020-04-01 15:36:33
 x001 | C      |    50 | 2020-04-01 15:36:34 | 2020-04-05 09:09:59
 x001 | B      |   100 | 2020-04-05 09:10:00 |
 x002 | F      |    30 | 2020-04-03 12:56:45 | 2020-04-03 12:59:14
 x002 | B      |   100 | 2020-04-03 12:59:15 | 2020-04-08 11:59:59
 x002 | A      |   150 | 2020-04-08 12:00:00 |
 x003 | F      |    10 | 2020-04-05 12:15:38 |
(7 rows)
```

`null`はデータの最大日時で埋めておく。

```sql
select
    opid,
    status,
    price,
    date,
    case when
        lead(date) over(partition by opid order by date asc) is null
        then (select max(date) from sfa)
        else lead(date) over(partition by opid order by date asc) - interval '1 second'
        end as leaddate
from
    sfa
where
    price > 0
;

 opid | status | price |        date         |      leaddate
------+--------+-------+---------------------+---------------------
 x001 | E      |    10 | 2020-04-01 12:54:04 | 2020-04-01 15:36:33
 x001 | C      |    50 | 2020-04-01 15:36:34 | 2020-04-05 09:09:59
 x001 | B      |   100 | 2020-04-05 09:10:00 | 2020-04-08 12:00:00
 x002 | F      |    30 | 2020-04-03 12:56:45 | 2020-04-03 12:59:14
 x002 | B      |   100 | 2020-04-03 12:59:15 | 2020-04-08 11:59:59
 x002 | A      |   150 | 2020-04-08 12:00:00 | 2020-04-08 12:00:00
 x003 | F      |    10 | 2020-04-05 12:15:38 | 2020-04-08 12:00:00
(7 rows)
```

あとは不等号`join`で頭とお尻の間の日時を紐付けて、各レコードを拡張する。ここではメモなので 1 時間単位だが、必要であれば 1 秒単位とか、細かくすれば良い。これで指定された期間によっては、同じ商談でも、指定された期間によっては、複数のレコードがとれるので、そこから最新時点の値だけとって重複しないように修正すれば OK。

```sql
with tmp as (
select
    opid,
    status,
    price,
    date,
    case when
        lead(date) over(partition by opid order by date asc) is null
        then (select max(date) from sfa)
        -- 次のjoinで < にするならマイナス1秒は不要
        else lead(date) over(partition by opid order by date asc) - interval '1 second'
        end as leaddate
from
    sfa
where
    price > 0
)
select
    *
from
    tmp as t
left join
    time_table as tt
on
    t.date <= tt.time_stamp and
    tt.time_stamp <= t.leaddate
order by
    t.opid asc,
    t.date asc,
    tt.time_stamp asc
limit 100;

 opid | status | price |        date         |      leaddate       |       time_stamp
------+--------+-------+---------------------+---------------------+------------------------
 x001 | E      |    10 | 2020-04-01 12:54:04 | 2020-04-01 15:36:33 | 2020-04-01 13:00:00+09
 x001 | E      |    10 | 2020-04-01 12:54:04 | 2020-04-01 15:36:33 | 2020-04-01 14:00:00+09
 x001 | E      |    10 | 2020-04-01 12:54:04 | 2020-04-01 15:36:33 | 2020-04-01 15:00:00+09
 x001 | C      |    50 | 2020-04-01 15:36:34 | 2020-04-05 09:09:59 | 2020-04-01 16:00:00+09
 x001 | C      |    50 | 2020-04-01 15:36:34 | 2020-04-05 09:09:59 | 2020-04-01 17:00:00+09
 x001 | C      |    50 | 2020-04-01 15:36:34 | 2020-04-05 09:09:59 | 2020-04-01 18:00:00+09
  (snip)
 x001 | C      |    50 | 2020-04-01 15:36:34 | 2020-04-05 09:09:59 | 2020-04-05 07:00:00+09
 x001 | C      |    50 | 2020-04-01 15:36:34 | 2020-04-05 09:09:59 | 2020-04-05 08:00:00+09
 x001 | C      |    50 | 2020-04-01 15:36:34 | 2020-04-05 09:09:59 | 2020-04-05 09:00:00+09
 x001 | B      |   100 | 2020-04-05 09:10:00 | 2020-04-08 12:00:00 | 2020-04-05 10:00:00+09
 x001 | B      |   100 | 2020-04-05 09:10:00 | 2020-04-08 12:00:00 | 2020-04-05 11:00:00+09
 x001 | B      |   100 | 2020-04-05 09:10:00 | 2020-04-08 12:00:00 | 2020-04-05 12:00:00+09
 x001 | B      |   100 | 2020-04-05 09:10:00 | 2020-04-08 12:00:00 | 2020-04-05 13:00:00+09
 x001 | B      |   100 | 2020-04-05 09:10:00 | 2020-04-08 12:00:00 | 2020-04-05 14:00:00+09
 x001 | B      |   100 | 2020-04-05 09:10:00 | 2020-04-08 12:00:00 | 2020-04-05 15:00:00+09
 x001 | B      |   100 | 2020-04-05 09:10:00 | 2020-04-08 12:00:00 | 2020-04-05 16:00:00+09
(100 rows)
```

さらに細かくするのであれば。`opid`の`status`ごとに`time_stamp`の開始時間、終了時間が少し厳密ではないので、頭とお尻ごとに識別子をつけて`least`と`greatest`で処理すればよい。例えば、`x001, E`であれば、

- 1 行目は頭なので、12:54:04 だけど 13:00:00 なので、`least`で 12:54:04 を取得
- 2 行目は間なので、そのまま
- 3 行目は尻なので、15:36:33 だけど 15:00:00 なので、`greates`で 15:36:33 を取得

```sql
 opid | status | price |        date         |      leaddate       |       time_stamp
------+--------+-------+---------------------+---------------------+------------------------
 x001 | E      |    10 | 2020-04-01 12:54:04 | 2020-04-01 15:36:33 | 2020-04-01 13:00:00+09 -- 12:54:04 だけど 13:00:00 なので、`least(date, time_stamp)`で 12:54:04 を取得
 x001 | E      |    10 | 2020-04-01 12:54:04 | 2020-04-01 15:36:33 | 2020-04-01 14:00:00+09 -- そのまま
 x001 | E      |    10 | 2020-04-01 12:54:04 | 2020-04-01 15:36:33 | 2020-04-01 15:00:00+09 -- 15:36:33 だけど 15:00:00 なので、`greates(time_stamp, leaddate)`で 15:36:33 を取得

```

## :closed_book: Reference

None
