## :memo: Overview

SQLの統計情報、実行計画、クエリチューニングに関して、おさらいした内容をまとめておく。BigQuery、スペック良さげのSnowflakeとかを使っているとパフォーマンスが良いクエリよりも可読性、安全性を優先してしまうので、ついついクエリが長くなりがち。なので、ここでは、SQLの統計情報、実行計画、クエリチューニングに関しておさらいしておく。

## :floppy_disk: Database

MySQL

## :bookmark: Tag

`xxx`

## :pencil2: SQL実行の流れ

SQL文を実行するときの内部処理をまとめる(厳密ではない)。SQLを実行すると、パース処理として、SQLとして正しい文法なのかチェックされ、テーブルなどが存在するかをチェックされ、過去に実行された同じSQLがないか共有プールチェック(ソフトパース)が行われる。そして、ハードパースとして、実行計画の複数作成し、その中で最も最適な実行計画で処理が開始される。

下記の通りバインド変数を使用した例だと、変数の値が変わっても同じSQLとみなされ、実行計画の作成は行わず、実行される。

```sql
SET @id = 1;
SET @id = 10;
SELECT * FROM customers WHERE id = @id;
```

## :pencil2: コストベースオプティマイザと実行計画

実行計画はDBのオプティマイザによって作成される。最適な実行計画を作成するために、オプティマイザは各種統計情報を利用する。統計情報とは、カラム、データ型、テーブルサイズ、インデックス、カーディナリティのこと。これらの統計情報を利用して、複数の実行計画を作成した後、最終的な実行計画が選択される。実行計画とは、処理内容と実行順をまとめているもの。

```sql
-- SQLは実行しない。実行計画だけ表示する。
EXPLAIN SELECT * FROM table;

-- SQLを実行して、実際の実行時間を含めた実行計画も表示する。
EXPLAIN ANALYZE SELECT * FROM table;
```

実行計画の各項目の見方は下記の通り。MySQLでの実行結果なので、PostgreSQLとは異なるので注意。

- Scan: 処理の方法。Table Scanはフルスキャンを意味する。
- cost: 推定実行コストで、結果のレコード数の推定値。
- rows: 結果の行数
- width: 結果の1行あたりの長さ
- actual time: 最初の行から全ての行を取得するのにかかった実際の時間(ミリ秒)

下記は`EXPLAIN ANALYZE`を実行した結果。`actual time=1.18..468`なので、実行時間はおよそ0.4秒。細かい話だと、468-1.18 = 466.82ミリ秒となるが、最初の行の取得にかかった時間の計算は、以降では考慮していない。

```sql
mysql> EXPLAIN ANALYZE SELECT * FROM products;

EXPLAIN                                                                                         |
------------------------------------------------------------------------------------------------+
-> Table scan on products  (cost=205313 rows=1.99e+6) (actual time=1.18..468 rows=2e+6 loops=1)¶|
```

実行計画を見る際は下記に注意すると、チューニングしやすい。

- 処理レコード数: 各処理でどれくらいの行数が取得されているか
- 実行時間: 長い実行時間の処理がないか
- アクセス方法: テーブルスキャン、インデックススキャンなのか
- JOIN方法や順番: ネステッドループジョイン、ハッシュジョイン、ソートマージジョインなのか、テーブルの結合順序
- パーティションの利用: パーティションの利用可否

## :pencil2: テーブルスキャン

テーブルスキャンはインデックスを使わず、全レコードを確認してからデータを取り出す。数件程度のテーブルなら問題はないが、数千、数億となるとテーブルスキャンでは非常に時間がかかってしまう。`SELECT *`やインデックスが付与されてないカラムでの条件づけ、`LIKE`検索などを利用するとテーブルスキャンされる。テーブルスキャンとは反対にインデックスを利用したインデックススキャンも存在する。

レコード数が少ないのであれば、インデックスは必要ない(つけてもあんまり変わらないので)。データのサイズが大きいのであれば、頻繁に条件設定で使用されるカラムなどはインデックスをつけるべきである。実行計画は内側の階層から実行されているので、テーブルスキャンした後に、フィルターの処理を行っていることがわかる。

```sql
mysql> EXPLAIN ANALYZE SELECT * FROM customers WHERE gender = 'F';

-> Filter: (customers.gender = 'F')  (cost=50406 rows=49661) (actual time=0.285..298 rows=250065 loops=1)
   -> Table scan on customers  (cost=50406 rows=496609) (actual time=0.198..248 rows=500000 loops=1)
```

## :pencil2: ジョインループ

`JOIN`などを利用するとSQL内部ではループ処理が行われる。ループ処理もいくつか種類があり、`Nested loop`が基本的な方法。キーとして利用しているテーブルの値をもとに、別のテーブルのキーを1行づつ検索され、これがレコード数分繰り返される。他にもハッシュジョインと呼ばれる方法も存在し、これはハッシュテーブルを用いて、ハッシュ化されたものを利用してテーブルを紐づける。キーを並び替えてからジョインするソートマージジョインという方法もある。

下記の実行計画を内側から読んでいくと、

```sql
-> Nested loop inner join  (cost=1.85e+6 rows=2.44e+6) (actual time=0.301..9541 rows=2.5e+6 loops=1)
    -> Filter: (sh.product_id is not null)  (cost=248895 rows=2.44e+6) (actual time=0.155..821 rows=2.5e+6 loops=1)
        -> Table scan on sh  (cost=248895 rows=2.44e+6) (actual time=0.152..653 rows=2.5e+6 loops=1)
    -> Single-row index lookup on p using PRIMARY (id=sh.product_id)  (cost=0.557 rows=1) (actual time=0.00329..0.00332 rows=1 loops=2.5e+6)
```

- 1. Table scan on sh: 0.6秒かかっている
- 2. Filter: (sh.product_id is not null): 同じ深さの場合、上の計画が実行されるので2番目はこちら。下の階層の実行時間も含み、0.8秒かかっている
- 3. Single-row index lookup on p: PKを用いたインデックススキャンが行われている。
- 4. Nested loop inner join: shが外部表、pが内部表としてネステッドループジョインが実行される。下の階層の実行時間も含むので、9秒かかったことがわかる。

このような順番で処理されていることがわかる。

## :pencil2: クエリチューニング

`ORDER BY`、`GROUP BY`、`SUM,COUNT,AVG,MIN,MAX`、`DISTINCT`、`UNION,INTERSECT,EXCEPT`、`WINDOW FUNCTION`はソートが発生するため、ソートの乱用は控える。基本原則は、必要な列、必要な行に絞り込んでから様々な処理を行う。特に`DISTINCT`は`EXISTS`で代替できるのであれば、そちらを検討する。例えば、顧客マスタに登録さている顧客の都道府県名のみをユニークに取り出したい場合、下記のように書くと、0.7秒ほどかかる。

```sql
mysql> EXPLAIN ANALYZE SELECT DISTINCT pr.name FROM prefectures AS pr INNER JOIN customers AS c ON pr.prefecture_code = c.prefecture_code;

-> Table scan on <temporary>  (cost=273880..280090 rows=496609) (actual time=712..712 rows=41 loops=1)
    -> Temporary table with deduplication  (cost=273880..273880 rows=496609) (actual time=712..712 rows=41 loops=1)
        -> Nested loop inner join  (cost=224219 rows=496609) (actual time=0.206..590 rows=500000 loops=1)
            -> Filter: (c.prefecture_code is not null)  (cost=50406 rows=496609) (actual time=0.171..181 rows=500000 loops=1)
                -> Table scan on c  (cost=50406 rows=496609) (actual time=0.168..146 rows=500000 loops=1)
            -> Single-row index lookup on pr using PRIMARY (prefecture_code=c.prefecture_code)  (cost=0.25 rows=1) (actual time=612e-6..646e-6 rows=1 loops=500000)
```

下記のように書き直すと、0.2秒ほどに短縮される。

```sql
mysql> EXPLAIN ANALYZE SELECT name FROM prefectures AS pr WHERE EXISTS (SELECT 1 FROM customers AS c WHERE pr.prefecture_code = c.prefecture_code);

-> Nested loop inner join  (cost=2.33e+6 rows=23.3e+6) (actual time=250..250 rows=41 loops=1)
    -> Table scan on pr  (cost=4.95 rows=47) (actual time=0.209..0.217 rows=47 loops=1)
    -> Single-row index lookup on <subquery2> using <auto_distinct_key> (prefecture_code=pr.prefecture_code)  (cost=100067..100067 rows=1) (actual time=5.32..5.32 rows=0.872 loops=47)
        -> Materialize with deduplication  (cost=100067..100067 rows=496609) (actual time=250..250 rows=41 loops=1)
            -> Filter: (c.prefecture_code is not null)  (cost=50406 rows=496609) (actual time=0.111..173 rows=500000 loops=1)
                -> Table scan on c  (cost=50406 rows=496609) (actual time=0.109..132 rows=500000 loops=1)
```

## :closed_book: Reference

None
